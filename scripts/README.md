# Downloading Tabular Data via the OCHRE API
#### by Miller C. Prosser (2020)
There are currently two scenarios for providing sets for download: (1) download an HTML table, (2) download a set directly from OCHRE.

## HTML Table Download
Sets published from OCHRE become available for viewing as HTML via the API. An API call transforms the DNF-XML using the default OCHRE XSLT. The output is a standard HTML table.
```html
<table id="ochreTable">
  <thead>
    <tr>
      <th/>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td/>
    </tr>
  </tbody>
</table>
```
If the set is published with the download option set to TRUE, then a download button is included on the HTML page. The button is generated by the default OCHRE XSLT.
```html
<div>
  <button type="button" onclick="exportTableToCSV('ochre_data.csv')">
    Export Table To CSV (tab-separated)
  </button>
</div>
```
The button launches a .js script called exportTableToCSV() that is embedded in the HTML page by the XSLT. The function in this script takes one argument, the filename. The function queries for the headings and rows, capturing the node list in the variables defined in the first section.

For example, the headings variable queries the DOM for nodes contained in the thead > tr context. It finds a nodelist of "th" elements, i.e. the column labels. The script assumes that the length of the headings list is 1, i.e. one row of heading labels. Within the headings nodelist, we query for all "th" elements and assign them to the cols variable. The cols variable will have a length that matches the number of column headings. We iterate over the cols variable and grab the innerText value of each node, pushing each value to the row list. Then we push each row value to the final csv variable, separating with a tab.

We do this process once for the headings and then again for the body of the table because we are creating the HTML table with a distinct thead and tbody section. When we create rows from the tbody element, we add another for-loop to iterate over the rows based on the length of the nodelist.
```JavaScript
function exportTableToCSV(filename) {
  var csv = [];
  var headings = document.querySelectorAll("thead tr");
  var rows = document.querySelectorAll("tbody tr");

  // Create the header row
    var row = [], cols = headings[0].querySelectorAll("th");
    for (var m = 0; m < cols.length; m++)
      row.push(cols[m].innerText);
    csv.push(row.join("\t"));

  // Create the data rows
  for (var i = 0; i < rows.length; i++) {
    var row = [], cols = rows[i].querySelectorAll("td");

    for (var j = 0; j < cols.length; j++)
      row.push(cols[j].innerText);

    csv.push(row.join("\t"));
  }

  // Download CSV file
  downloadCSV(csv.join("\n"), filename);
}
```
The script ends by calling a second script that downloads the CSV file. This script comes from various online samples, will slight updates to accomodate CSV format.
```JavaScript
function downloadCSV(csv, filename) {
  var csvFile;
  var downloadLink;

  // CSV file
  csvFile = new Blob([csv], { type: "text/csv" });

  // Download link
  downloadLink = document.createElement("a");

  // File name
  downloadLink.download = filename;

  // Create a link to the file
  downloadLink.href = window.URL.createObjectURL(csvFile);

  // Hide download link
  downloadLink.style.display = "none";

  // Add the link to DOM
  document.body.appendChild(downloadLink);

  // Click download link
  downloadLink.click();
}
```
The point here is that any set published with the download option set to TRUE can be downloaded using the default download button provided by the default OCHRE XSLT.


## Direct Download
In contrast to the default method above, the Direct Download method requires user intervention from the project frontend developer. In this scenario, the project wishes to share a set of information as a direct download, but does not wish to present that set as an HTML page first. There may be many reasons for this choice. Perhaps the set is too large to present as HTML. Perhaps the idea is simply to place the download link/button in a place where an HTML table doesn't make sense. In any case, in this scenario, the project publishes a set from OCHRE as usual. The frontend developer assigns the UUID of the set to a link or button.
```html
<button id="uuid" onclick="openCSVPage(this.id)">
  Prepare Download
</button>
```
This button launches a script that will open a download page and pass the set UUID to this new page. Therefore, the frontend developer will need to include the openCSVPage() script on the page with the button/link and the ochreCSV.html page with their site.
```html
  <script>
    function openCSVPage(clicked_id) {
      var uuid = clicked_id;
      var w = window.open("ochreCSV.html");
      w.uuid = uuid;
    }
  </script>
```
The ochreCSV.html page includes a script that will launch when the page is loaded. See the onload attribute of body. Notice also that the divs on this page are styled to either display or not display. By default, the page gives a friendly message indicating that the file is being prepared. This message stays on the screen until the displayResult() script is complete. (Results may vary across browsers.) This brief moment represents the duration of the XSLT transformation.
```html
<body onload="displayResult()">
  <div>
    <div id="preDownloadDiv" style="display: block;">
      <h2>Your file is being prepared...</h2>
    </div>
    <div id="downloadDiv" style="display: none;">
      <h2>The file has been formatted for download.</h2>
      <button onclick="exportTableToCSV('ochreDataCSV.csv')">Save As Tab-Delimited CSV File</button>
      <h2>Disable pop-up blocker to allow downloads from this page.</h2>
      <p>Note: if the columns do not align correctly, then import/open as tab-separated.</p>
    </div>
    <div style="display: none;" id="tblexportData" />
  </div>
</body>
```
The default script performs an XSLT transformation that delivers the output to a hidden div on the html page. This code is pretty much boiler plate stuff that can be found on various sites. The update for our purposes is the use of the **uuid** variable delivered to this page from the click that launched this page. The other unique twist in our version of the script is the div display manipulation. Once the transformation is complete, we hide the default message and display that div that includes the download button. (This little trick seems not to work in Safari.)
```JavaScript
    function loadXMLDoc(filename) {
      if (window.ActiveXObject) {
        xhttp = new ActiveXObject("Msxml2.XMLHTTP");
      }
      else {
        xhttp = new XMLHttpRequest();
      }
      xhttp.open("GET", filename, false);
      try { xhttp.responseType = "msxml-document" } catch (err) { } // Helping IE11
      xhttp.send("");
      return xhttp.responseXML;
    }

    function displayResult() {
      //The uuid value comes from the button click ID.
      xml = loadXMLDoc("http://ochre.lib.uchicago.edu/ochre?uuid=" + uuid);
      xsl = loadXMLDoc("http://ochre.lib.uchicago.edu/ochre/ochre_csv.xsl");
      // code for IE
      if (window.ActiveXObject || xhttp.responseType == "msxml-document") {
        ex = xml.transformNode(xsl);
        document.getElementById("tblexportData").innerHTML = ex;
      }
      // code for Chrome, Firefox, Opera, etc.
      else if (document.implementation && document.implementation.createDocument) {
        xsltProcessor = new XSLTProcessor();
        xsltProcessor.importStylesheet(xsl);
        resultDocument = xsltProcessor.transformToFragment(xml, document);
        document.getElementById("tblexportData").appendChild(resultDocument);
      }
      // onload, display the button
      document.getElementById("preDownloadDiv").setAttribute("style", "display: none;");
      document.getElementById("downloadDiv").setAttribute("style", "display: block;");
    }
```
This transformation uses a customized XSLT file that creates as standard HTML table. The XSLT expects a standard DNF-XML file from OCHRE, containing an //items node. After the //items node, the set may contain any type of item, e.g. //items/spatialUnit/. The table heading is derived **only** from the first item in the //items list. (Note: XML nodes begin at 1, not 0.) The Name and Description column titles are hard-coded into the transformation. (Items published in a set will include an empty node when the description field is blank.) The stylesheet looks at the first item in the list and extracts the property labels to use as the remaining column titles.

The next section performs a for-each loop on each item in the //items list to extract the values, first for the name and description, then for the attested properties. Columns are tab-delimited. Tab-delimited seems to be the best choice because names and descriptions frequently include commas, semi-colons, colons, dashes, periods, etc. They rarely (never?) include tab characters. After each property value, the stylesheet checks current node position to see if the current property value is the last in the node list. If not, it inserts a tab (\&#9;) and continues. After the final property, we insert a Line Feed character (\&#xa;) to create a new row.
```xml
<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet version="1.0" xmlns:ino="http://namespaces.softwareag.com/tamino/response2" xmlns:xql="http://metalab.unc.edu/xql" xmlns:xq="http://namespaces.softwareag.com/tamino/XQuery/result" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
    <xsl:output method="html" encoding="UTF-8" omit-xml-declaration="yes"/>
    <xsl:strip-space elements="*"/>
    <xsl:template match="text()"> </xsl:template>
    <xsl:template match="set">
        <table id="ochreTable">
            <thead id="ochreTableColumns">
                <tr>
                    <!--NAME AND DESCRIPTION-->
                    <th> Name </th>
                    <th> Description </th>
                    <!--PROPERTIES-->
                    <xsl:for-each select="//items/*[1]">
                        <xsl:for-each select="properties/property">
                            <th>
                                <xsl:value-of select="label"/>
                            </th>
                        </xsl:for-each>
                    </xsl:for-each>
                </tr>
            </thead>
            <tbody id="ochreTableBody">
                <xsl:for-each select="//items/*">
                    <xsl:variable name="uuid" select="@uuid"/>
                    <tr class="ochreTableRows">
                        <td class="Name">
                            <xsl:value-of select="identification/label"/>
                        </td>
                        <td>
                            <xsl:value-of select="description"/>
                        </td>
                        <xsl:for-each select="properties/property">
                            <td>
                                <xsl:for-each select="value">
                                    <xsl:value-of select="."/>
                                    <xsl:if test="not(position() = last())">
                                        <xsl:text>; </xsl:text>
                                    </xsl:if>
                                </xsl:for-each>
                            </td>
                        </xsl:for-each>
                    </tr>
                </xsl:for-each>
            </tbody>
        </table>
    </xsl:template>
</xsl:stylesheet>

```
As a final note, we strip white space; possibly not necessary.
```xml
<xsl:strip-space elements="*"/>
```
We also catch and kill any text nodes not in the set template. Without this line of code, other text nodes may be passed through the transformation.
```xml
<xsl:template match="text()"> </xsl:template>
```
When the page is loaded, the user can click the download button to launch the exportTableToCSV() script. This launches the same script as in the scenario above.
